<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ãƒ›ãƒ¼ãƒ </title>
<link rel="icon" href="https://upload.wikimedia.org/wikipedia/commons/1/19/Google_Classroom_Logo.svg">
<!-- ãƒ—ãƒ­ã‚­ã‚·ã¸ã®preconnect/dns-prefetchã¯ä¸è¦ã«ãªã£ãŸã®ã§å‰Šé™¤å¯ã§ã™ãŒæ®‹ã—ã¦ã‚‚OK -->
<link rel="preconnect" href="https://teaching-materials-r4zf.onrender.com">
<link rel="dns-prefetch" href="https://teaching-materials-r4zf.onrender.com">
<style>
  /* --- æ—¢å­˜ã®CSSã¯ã“ã“ã«ãã®ã¾ã¾ --- */
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,'Segoe UI',Roboto,'Hiragino Kaku Gothic ProN',Meiryo,sans-serif;background:#fff;color:#111}
  a{color:inherit;text-decoration:none}
  img{max-width:100%;display:block}
  header{position:sticky;top:0;z-index:40;background:#fff;border-bottom:1px solid #eee;display:flex;align-items:center;padding:8px 16px;gap:12px;height:64px}
  .logo{display:flex;align-items:center;gap:8px;cursor:pointer}
  .logo .icon{width:36px;height:36px;border-radius:6px;background:#ff0000;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700}
  .search{flex:1;display:flex;justify-content:center}
  .search input{width:100%;max-width:720px;padding:10px 14px;border-radius:20px;border:1px solid #ddd;outline:none}
  .actions{display:flex;gap:12px;align-items:center}
  main{display:flex;gap:20px;padding:16px;align-items:flex-start}
  .content{flex:1}
  .video-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:16px}
  .card{cursor:pointer}
  .thumb{position:relative;border-radius:6px;overflow:hidden;background:#eee}
  .thumb img{width:100%;height:auto;display:block}
  .meta{display:flex;gap:12px;margin-top:8px}
  .channel-thumb{width:36px;height:36px;border-radius:50%;flex:0 0 36px;background:#ddd;overflow:hidden}
  .meta .info{flex:1}
  .meta .info .title{font-weight:600;line-height:1.2;margin-bottom:6px}
  .meta .info .sub{color:#606060;font-size:13px}
  .watch-container{display:flex;gap:20px}
  .main-col{flex:0 0 60%}
  .side-col{flex:0 0 40%}
  .player-box{background:#000;aspect-ratio:16/9;border-radius:6px;overflow:hidden}
  .player-meta{margin-top:12px}
  .player-meta h1{font-size:18px;margin:0 0 8px 0}
  .stats{color:#606060;font-size:13px;margin-bottom:12px;display:flex;gap:12px;flex-wrap:wrap}
  .channel-row{display:flex;align-items:center;gap:12px;padding:12px 0;border-top:1px solid #eee;border-bottom:1px solid #eee;margin-top:12px}
  .channel-row img{width:48px;height:48px;border-radius:50%;overflow:hidden}
  .channel-row .ch-info{flex:1}
  .btn-sub{background:#cc0000;color:#fff;padding:8px 12px;border-radius:16px;font-weight:700;cursor:pointer}
  .comments{margin-top:12px}
  .comment{display:flex;gap:12px;padding:10px 0;border-bottom:1px solid #f0f0f0}
  .comment img{width:36px;height:36px;border-radius:50%}
  .comment .c-body{flex:1}
  .comment .c-body .name{font-weight:700;font-size:13px}
  .comment .c-body .text{color:#333;margin-top:6px}
  .related-item{display:flex;gap:12px;padding:8px 0;border-bottom:1px solid #f5f5f5;cursor:pointer}
  .related-thumb{width:168px;flex:0 0 168px;overflow:hidden;border-radius:6px}
  .related-info{flex:1}
  .related-info .title{font-size:14px;font-weight:600}
  @media(max-width:900px){
    main{padding:12px}
    .watch-container{flex-direction:column}
    .main-col,.side-col{flex:1 1 100%}
    .related-thumb{width:120px;flex:0 0 120px}
    .search input{max-width:420px}
  }
  .watch-container { display: flex; gap: 20px; height: calc(100vh - 64px - 32px); }
  .main-col { flex: 0 0 60%; display: flex; flex-direction: column; overflow-y: auto; padding-right: 4px; }
  .side-col { flex: 0 0 40%; display: flex; flex-direction: column; overflow-y: auto; padding-left: 4px; }
  .player-box { flex: 0 0 auto; }
  .comments { flex: 1 1 auto; overflow-y: auto; }
</style>
</head>
<body>
    <header>
      <div class="logo" id="homeBtn" title="Home">
        <div class="icon">Y</div>
        <div style="font-weight:700">YouTube</div>
      </div>
      <div class="search">
        <input id="searchInput" placeholder="æ¤œç´¢" autocomplete="off" />
      </div>
      <div class="actions">
        <div title="ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ" style="width:36px;height:36px;border-radius:50%;background:#eee"></div>
      </div>
    </header>
    <main>
      <div class="content" id="app"></div>
    </main>
    <script>
      /* YouTubeé¢¨ã‚·ãƒ³ã‚°ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ãƒ¢ï¼ˆPiped API ç‰ˆï¼‰ */

      const PIPED_API_BASE = '/piped';  // â† ã“ã‚Œã«å¤‰æ›´ï¼ã‚µãƒ¼ãƒãƒ¼ã®ãƒ—ãƒ­ã‚­ã‚·çµŒç”±

      const MAX_RESULTS = 12;
      const el = id => document.getElementById(id);
      const app = el('app');
      const searchInput = el('searchInput');
      const homeBtn = el('homeBtn');

      let channelThumbCache = {};
      let homeLoading = false;
      let observerMap = new Map();

      function fmtNum(n){
        if(n==null) return '';
        n = Number(n);
        if(n>=1e9) return (n/1e9).toFixed(1)+'B';
        if(n>=1e6) return (n/1e6).toFixed(1)+'M';
        if(n>=1e3) return (n/1e3).toFixed(1)+'K';
        return String(n);
      }

      function timeAgo(dateStr){
        // Pipedã®uploadedDateã¯ "X days ago" å½¢å¼ãŒå¤šã„ãŒã€Dateã§ãƒ‘ãƒ¼ã‚¹å¯èƒ½ãªã‚‰ä½¿ã†
        const d = new Date(dateStr);
        if (isNaN(d.getTime())) return dateStr; // ãƒ‘ãƒ¼ã‚¹å¤±æ•—æ™‚ã¯ç”Ÿæ–‡å­—åˆ—
        const s = Math.floor((Date.now()-d.getTime())/1000);
        if(s<60) return s + 'ç§’å‰';
        if(s<3600) return Math.floor(s/60)+'åˆ†å‰';
        if(s<86400) return Math.floor(s/3600)+'æ™‚é–“å‰';
        if(s<2592000) return Math.floor(s/86400)+'æ—¥å‰';
        if(s<31536000) return Math.floor(s/2592000)+'ãƒ¶æœˆå‰';
        return Math.floor(s/31536000)+'å¹´ä»¥ä¸Šå‰';
      }

      // Piped ç”¨ã‚·ãƒ³ãƒ—ãƒ« fetch ãƒ©ãƒƒãƒ‘ãƒ¼
// Piped ç”¨ã‚·ãƒ³ãƒ—ãƒ« fetch ãƒ©ãƒƒãƒ‘ãƒ¼ï¼ˆä¿®æ­£ç‰ˆï¼‰
async function pipedFetch(endpoint, params = {}) {
  // endpoint ãŒ / ã§å§‹ã¾ã£ã¦ã„ã‚‹å ´åˆã‚‚OKã«ã™ã‚‹
  let path = endpoint.startsWith('/') ? endpoint : '/' + endpoint;
  
  // ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å®‰å…¨ã«æ§‹ç¯‰
  const queryString = new URLSearchParams(params).toString();
  const fullPath = queryString ? `${path}?${queryString}` : path;
  
  // ç›¸å¯¾ãƒ‘ã‚¹ã§ fetchï¼ˆã‚µãƒ¼ãƒãƒ¼ãƒ—ãƒ­ã‚­ã‚·ç”¨ï¼‰
  const response = await fetch(`${PIPED_API_BASE}${fullPath}`, {
    method: 'GET',
    headers: {
      'Accept': 'application/json'
    }
  });

  if (!response.ok) {
    throw new Error(`Piped proxy error: ${response.status} ${response.statusText}`);
  }

  return response.json();
}
      // ãƒãƒ£ãƒ³ãƒãƒ«ã‚µãƒ ãƒã‚¤ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆPipedç‰ˆï¼‰
      async function getChannelThumbPiped(channelId) {
        if (channelThumbCache[channelId]) return channelThumbCache[channelId];
        try {
          const data = await pipedFetch(`/channel/${channelId}`);
          const thumb = data.avatarUrl || '';
          channelThumbCache[channelId] = thumb;
          return thumb;
        } catch (e) {
          console.warn('channel thumb failed', e);
          return '';
        }
      }

      // ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ï¼ˆå¤‰æ›´ãªã—ï¼‰
      window.addEventListener('hashchange', renderByHash);
      homeBtn.addEventListener('click', () => { location.hash = ''; });
      searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') performSearch(searchInput.value.trim());
      });
      renderByHash();

      function renderByHash() {
        const h = location.hash.slice(1);
        if (!h) return renderHome();
        const [k, v] = h.split('=');
        if (k === 'watch') return renderWatch(v);
        if (k === 'channel') return renderChannel(v);
        if (k === 'search') {
          searchInput.value = decodeURIComponent(v || '');
          performSearch(decodeURIComponent(v || ''));
          return;
        }
        renderHome();
      }

      // ãƒ›ãƒ¼ãƒ ï¼ˆtrending JPï¼‰
      function renderHome() {
        app.innerHTML = `
          <section id="homeSection">
            <div style="margin:12px 0;font-weight:700;font-size:18px">ãŠã™ã™ã‚</div>
            <div class="video-grid" id="videoGrid"></div>
            <div id="homeSentinel" style="height:32px"></div>
          </section>
        `;
        setupHomeInfinite();
        loadHome();
      }

      async function loadHome() {
        if (homeLoading) return;
        homeLoading = true;
        const grid = el('videoGrid');
        try {
          const data = await pipedFetch('/trending', { region: 'JP' });
          for (const item of data || []) {
            const card = await makeVideoCard(item);  // åå‰ã¯ãã®ã¾ã¾ã€å†…éƒ¨ã§Pipedå¯¾å¿œ
            grid.appendChild(card);
          }
        } catch (e) {
          console.error(e);
          grid.innerHTML += `<div style="color:#c00">èª­ã¿è¾¼ã¿å¤±æ•—: ${escapeHtml(e.message)}</div>`;
        } finally {
          homeLoading = false;
        }
      }

      // ã‚«ãƒ¼ãƒ‰ç”Ÿæˆï¼ˆPipedãƒ‡ãƒ¼ã‚¿æ§‹é€ å¯¾å¿œï¼‰
      async function makeVideoCard(item) {
        const vid = item.url?.split('v=')[1] || item.url?.split('/').pop() || '';
        const title = item.title || '';
        const th = item.thumbnail || '';
        const chId = item.uploaderUrl?.split('/').pop() || '';
        const chTitle = item.uploaderName || '';
        const views = item.views || 0;
        const publishedAt = item.uploadedDate || item.uploaded || '';

        const channelThumb = await getChannelThumbPiped(chId);

        const div = document.createElement('div');
        div.className = 'card';
        div.innerHTML = `
          <div class="thumb" data-vid="${vid}">
            <img src="${th}" alt="">
          </div>
          <div class="meta">
            <div class="channel-thumb"><img src="${channelThumb}" alt=""></div>
            <div class="info">
              <div class="title">${escapeHtml(title)}</div>
              <div class="sub">
                <a href="#channel=${chId}" data-channel="${chId}" class="ch-link">${escapeHtml(chTitle)}</a>
                ãƒ» ${fmtNum(views)} å›è¦–è´ ãƒ» ${timeAgo(publishedAt)}
              </div>
            </div>
          </div>
        `;
        div.querySelector('.thumb').addEventListener('click', () => {
          location.hash = `watch=${vid}`;
        });
        div.querySelector('.ch-link').addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          location.hash = `channel=${chId}`;
        });
        return div;
      }

      function setupHomeInfinite() {
        const sentinel = el('homeSentinel');
        if (!sentinel) return;
        const io = new IntersectionObserver(entries => {
          entries.forEach(ent => { if (ent.isIntersecting) loadHome(); });  // Pipedã¯ãƒšãƒ¼ã‚¸ãƒ³ã‚°å¼±ã„ã®ã§å†èª­è¾¼
        }, { rootMargin: '400px' });
        io.observe(sentinel);
        observerMap.set('home', io);
      }

      // æ¤œç´¢æ©Ÿèƒ½
      async function performSearch(q) {
        if (!q) return renderHome();
        location.hash = `search=${encodeURIComponent(q)}`;
        app.innerHTML = `
          <section>
            <div style="margin:12px 0;font-weight:700;font-size:18px">æ¤œç´¢çµæœ: ${escapeHtml(q)}</div>
            <div class="video-grid" id="videoGrid"></div>
            <div id="searchSentinel" style="height:32px"></div>
          </section>
        `;
        const grid = el('videoGrid');
        let loading = false;

        const loadMore = async () => {
          if (loading) return;
          loading = true;
          try {
            const data = await pipedFetch('/search', { q, filter: 'videos' });
            for (const item of data || []) {
              const card = await makeVideoCard(item);
              grid.appendChild(card);
            }
          } catch (e) {
            console.error(e);
            grid.innerHTML += `<div style="color:#c00">èª­ã¿è¾¼ã¿å¤±æ•—: ${escapeHtml(e.message)}</div>`;
          } finally {
            loading = false;
          }
        };

        const sentinel = el('searchSentinel');
        const io = new IntersectionObserver(entries => {
          entries.forEach(ent => { if (ent.isIntersecting) loadMore(); });
        }, { rootMargin: '400px' });
        io.observe(sentinel);
        observerMap.set('search', io);
        loadMore();
      }

      // å‹•ç”»å†ç”Ÿç”»é¢
      async function renderWatch(videoId) {
        observerMap.forEach(o => o.disconnect());
        observerMap.clear();
        app.innerHTML = `<div>èª­ã¿è¾¼ã¿ä¸­...</div>`;

        try {
          const data = await pipedFetch(`/streams/${videoId}`);
          if (!data || !data.title) throw new Error('å‹•ç”»ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');

          const title = data.title;
          const views = data.views || 0;
          const likes = data.likes || 0;
          const uploaded = data.uploadedDate || '';
          const description = data.description || '';
          const chName = data.uploader || '';
          const chId = data.uploaderUrl?.split('/').pop() || '';
          const chThumb = data.uploaderAvatar || '';
          const chSubs = data.uploaderSubscriberCount || 0;

          app.innerHTML = `
            <div class="watch-container">
              <div class="main-col">
                <div class="player-box">
                  <iframe id="videoIframe" src="https://www.youtube.com/embed/${videoId}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="width:100%;height:100%;"></iframe>
                </div>
                <div class="player-meta">
                  <h1>${escapeHtml(title)}</h1>
                  <div class="stats">
                    <div>${fmtNum(views)} å›è¦–è´</div>
                    <div>ãƒ»</div>
                    <div>${timeAgo(uploaded)}</div>
                    <div style="margin-left:auto;font-weight:700">
                      ${fmtNum(likes)} ğŸ‘
                    </div>
                    <select id="playerSelect" style="margin-left:8px">
                      <option value="official" selected>å…¬å¼ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</option>
                      <option value="original">ã‚ªãƒªã‚¸ãƒŠãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</option>
                    </select>
                  </div>
                  <div class="channel-row">
                    <img src="${chThumb}" alt="">
                    <div class="ch-info">
                      <div style="font-weight:700">
                        <a href="#channel=${chId}" class="watch-ch-link" style="text-decoration:none;color:inherit">
                          ${escapeHtml(chName)}
                        </a>
                      </div>
                      <div style="color:#606060;font-size:13px">${fmtNum(chSubs)} äººã®ç™»éŒ²è€…</div>
                    </div>
                    <div class="btn-sub">ç™»éŒ²</div>
                  </div>
                  <div style="margin-top:12px;color:#333">${escapeHtml(description).slice(0,600)}${description.length>600 ? 'â€¦' : ''}</div>
                  <div class="comments" id="commentsArea">
                    <h3 style="margin-top:12px">ã‚³ãƒ¡ãƒ³ãƒˆ</h3>
                    <div id="commentsList"></div>
                    <div id="commentsSentinel" style="height:32px"></div>
                  </div>
                </div>
              </div>
              <aside class="side-col">
                <div style="font-weight:700;margin-bottom:8px">æ¬¡ã«å†ç”Ÿ</div>
                <div id="relatedList"></div>
              </aside>
            </div>
          `;

          const watchChLink = app.querySelector('.watch-ch-link');
          if (watchChLink) {
            watchChLink.addEventListener('click', e => {
              e.preventDefault();
              e.stopPropagation();
              location.hash = `channel=${chId}`;
            });
          }

          setupComments(videoId);
          loadRelated(videoId, data.relatedStreams || []);

          const playerSelect = document.getElementById('playerSelect');
          const iframe = document.getElementById('videoIframe');
          playerSelect.addEventListener('change', () => {
            if (playerSelect.value === 'official') {
              iframe.src = `https://www.youtube.com/embed/${videoId}`;
            } else {
              iframe.src = `https://teaching-materials-r4zf.onrender.com/watch.html?id=${videoId}`;
            }
          });
        } catch (e) {
          app.innerHTML = `<div style="color:#c00">èª­ã¿è¾¼ã¿å¤±æ•—: ${escapeHtml(e.message)}</div>`;
        }
      }

      // é–¢é€£å‹•ç”»ï¼ˆstreams ã‹ã‚‰ç›´æ¥ relatedStreams ã‚’ä½¿ã†ï¼‰
      async function loadRelated(videoId, relatedStreams = []) {
        const container = document.getElementById('relatedList');
        container.innerHTML = '<div>èª­ã¿è¾¼ã¿ä¸­â€¦</div>';

        if (relatedStreams.length === 0) {
          try {
            const data = await pipedFetch(`/streams/${videoId}`);
            relatedStreams = data.relatedStreams || [];
          } catch (e) {
            console.warn('relatedStreams fetch failed', e);
          }
        }

        if (relatedStreams.length) {
          container.innerHTML = '';
          for (const item of relatedStreams) {
            const vid = item.url?.split('v=')[1] || '';
            const div = document.createElement('div');
            div.className = 'related-item';
            div.innerHTML = `
              <div class="related-thumb"><img src="${item.thumbnail || ''}" alt=""></div>
              <div class="related-info">
                <div class="title">${escapeHtml(item.title || '')}</div>
                <div style="color:#606060;font-size:13px">${escapeHtml(item.uploaderName || '')} ãƒ» ${fmtNum(item.views || 0)} å›</div>
              </div>
            `;
            div.addEventListener('click', () => location.hash = `watch=${vid}`);
            container.appendChild(div);
          }
        } else {
          container.innerHTML = '<div style="color:#606060">é–¢é€£å‹•ç”»ãŒè¦‹ã¤ã‹ã‚‰ãªã„</div>';
        }
      }

      // ã‚³ãƒ¡ãƒ³ãƒˆï¼ˆç„¡é™ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰
      let commentsPageToken = {};
      async function setupComments(videoId) {
        const list = document.getElementById('commentsList');
        list.innerHTML = '';
        commentsPageToken[videoId] = null;
        let loading = false;

        const loadMore = async () => {
          if (loading) return;
          loading = true;
          try {
            const params = { sort_by: 'top' }; // relevance ç›¸å½“ã¯ top ãŒå¤šã„
            if (commentsPageToken[videoId]) params.nextpage = commentsPageToken[videoId];
            const res = await pipedFetch(`/comments/${videoId}`, params);
            commentsPageToken[videoId] = res.nextpage || null;

            for (const c of res.comments || []) {
              const div = document.createElement('div');
              div.className = 'comment';
              div.innerHTML = `
                <img src="${c.authorThumbnails?.[c.authorThumbnails.length-1]?.url || ''}" alt="">
                <div class="c-body">
                  <div class="name">${escapeHtml(c.author || '')} ãƒ» <span style="color:#606060;font-size:12px">${timeAgo(c.published || '')}</span></div>
                  <div class="text">${escapeHtml(c.content || '')}</div>
                </div>
              `;
              list.appendChild(div);
            }
            if (!res.comments?.length && !list.innerHTML) {
              list.innerHTML = '<div style="color:#606060">ã‚³ãƒ¡ãƒ³ãƒˆãŒå­˜åœ¨ã—ãªã„ã‹ã€éè¡¨ç¤º</div>';
            }
          } catch (e) {
            console.error(e);
            list.innerHTML += `<div style="color:#c00">ã‚³ãƒ¡ãƒ³ãƒˆèª­ã¿è¾¼ã¿å¤±æ•—</div>`;
          } finally {
            loading = false;
          }
        };

        const sentinel = el('commentsSentinel');
        const io = new IntersectionObserver(entries => {
          entries.forEach(ent => { if (ent.isIntersecting) loadMore(); });
        }, { rootMargin: '400px' });
        io.observe(sentinel);
        observerMap.set(`comments_${videoId}`, io);
        loadMore();
      }

      // ãƒãƒ£ãƒ³ãƒãƒ«ãƒšãƒ¼ã‚¸
      async function renderChannel(channelId) {
        app.innerHTML = `<div>ãƒãƒ£ãƒ³ãƒãƒ«èª­ã¿è¾¼ã¿ä¸­â€¦</div>`;
        try {
          const data = await pipedFetch(`/channel/${channelId}`);
          if (!data || !data.name) throw new Error('ãƒãƒ£ãƒ³ãƒãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');

          const title = data.name;
          const desc = data.description || '';
          const thumb = data.avatarUrl || '';
          const subs = data.subscriberCount || 0;

          app.innerHTML = `
            <div style="display:flex;gap:12px;align-items:center;margin-bottom:12px">
              <img src="${thumb}" style="width:88px;height:88px;border-radius:50%">
              <div>
                <div style="font-weight:700;font-size:18px">${escapeHtml(title)}</div>
                <div style="color:#606060">${fmtNum(subs)} äººã®ç™»éŒ²è€…</div>
                <div style="margin-top:8px"><button class="btn-sub">ç™»éŒ²</button></div>
              </div>
            </div>
            <div style="font-size:13px;color:#333;margin-bottom:12px">${escapeHtml(desc).slice(0,500)}${desc.length>500?'â€¦':''}</div>
            <div style="font-weight:700;margin:12px 0">å‹•ç”»</div>
            <div class="video-grid" id="channelVideos"></div>
            <div id="channelSentinel" style="height:32px"></div>
          `;

          const grid = el('channelVideos');
          let loading = false;

          const loadMore = async () => {
            if (loading) return;
            loading = true;
            try {
              // Pipedã®channelã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§videosãŒè¿”ã‚‹ï¼ˆä¸€éƒ¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã¿nextpageå¯¾å¿œï¼‰
              const chData = await pipedFetch(`/channel/${channelId}`); // å†å–å¾—ï¼ˆç°¡ç•¥åŒ–ï¼‰
              for (const v of chData.relatedStreams || chData.videos || []) {
                const card = await makeVideoCard(v);
                grid.appendChild(card);
              }
            } catch (e) {
              console.error(e);
              grid.innerHTML += `<div style="color:#c00">èª­ã¿è¾¼ã¿å¤±æ•—</div>`;
            } finally {
              loading = false;
            }
          };

          const sentinel = el('channelSentinel');
          const io = new IntersectionObserver(entries => {
            entries.forEach(ent => { if (ent.isIntersecting) loadMore(); });
          }, { rootMargin: '400px' });
          io.observe(sentinel);
          observerMap.set(`channel_${channelId}`, io);
          loadMore();
        } catch (e) {
          app.innerHTML = `<div style="color:#c00">ãƒãƒ£ãƒ³ãƒãƒ«èª­ã¿è¾¼ã¿å¤±æ•—: ${escapeHtml(e.message)}</div>`;
        }
      }

      function escapeHtml(s = '') {
        return String(s)
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;')
          .replaceAll('"', '&quot;')
          .replaceAll("'", '&#39;');
      }
    </script>

    <!-- ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ç”»é¢éƒ¨åˆ†ï¼ˆå¤‰æ›´ãªã—ï¼‰ -->
    <script>
      const correctPassword = "manabinotobira";
      const input = document.getElementById('passwordInput');
      const btn = document.getElementById('passwordBtn');
      const msg = document.getElementById('passwordMsg');
      const screen = document.getElementById('passwordScreen');
      const content = document.getElementById('mainContent');
      btn.addEventListener('click', () => {
        if(input.value === correctPassword){
          screen.style.display = 'none';
          content.style.display = 'block';
        } else {
          msg.textContent = 'åˆ©ç”¨ã‚³ãƒ¼ãƒ‰ãŒé•ã„ã¾ã™';
          input.value = '';
          input.focus();
        }
      });
      input.addEventListener('keydown', e => {
        if(e.key === 'Enter') btn.click();
      });

      window.addEventListener('load', () => {
        fetch('https://teaching-materials-r4zf.onrender.com/', { mode: 'no-cors' }).catch(()=>{});
        fetch('https://teaching-materials-r4zf.onrender.com/watch.html?id=dummy', { mode: 'no-cors' }).catch(()=>{});
      });
    </script>
</body>
</html>
