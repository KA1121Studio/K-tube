<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ホーム</title>
<link rel="icon" href="https://upload.wikimedia.org/wikipedia/commons/1/19/Google_Classroom_Logo.svg">
<!-- プロキシへのpreconnect/dns-prefetchは不要になったので削除可ですが残してもOK -->
<link rel="preconnect" href="https://teaching-materials-r4zf.onrender.com">
<link rel="dns-prefetch" href="https://teaching-materials-r4zf.onrender.com">
<style>
  /* --- 既存のCSSはここにそのまま --- */
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,'Segoe UI',Roboto,'Hiragino Kaku Gothic ProN',Meiryo,sans-serif;background:#fff;color:#111}
  a{color:inherit;text-decoration:none}
  img{max-width:100%;display:block}
  header{position:sticky;top:0;z-index:40;background:#fff;border-bottom:1px solid #eee;display:flex;align-items:center;padding:8px 16px;gap:12px;height:64px}
  .logo{display:flex;align-items:center;gap:8px;cursor:pointer}
  .logo .icon{width:36px;height:36px;border-radius:6px;background:#ff0000;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700}
  .search{flex:1;display:flex;justify-content:center}
  .search input{width:100%;max-width:720px;padding:10px 14px;border-radius:20px;border:1px solid #ddd;outline:none}
  .actions{display:flex;gap:12px;align-items:center}
  main{display:flex;gap:20px;padding:16px;align-items:flex-start}
  .content{flex:1}
  .video-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:16px}
  .card{cursor:pointer}
  .thumb{position:relative;border-radius:6px;overflow:hidden;background:#eee}
  .thumb img{width:100%;height:auto;display:block}
  .meta{display:flex;gap:12px;margin-top:8px}
  .channel-thumb{width:36px;height:36px;border-radius:50%;flex:0 0 36px;background:#ddd;overflow:hidden}
  .meta .info{flex:1}
  .meta .info .title{font-weight:600;line-height:1.2;margin-bottom:6px}
  .meta .info .sub{color:#606060;font-size:13px}
  .watch-container{display:flex;gap:20px}
  .main-col{flex:0 0 60%}
  .side-col{flex:0 0 40%}
  .player-box{background:#000;aspect-ratio:16/9;border-radius:6px;overflow:hidden}
  .player-meta{margin-top:12px}
  .player-meta h1{font-size:18px;margin:0 0 8px 0}
  .stats{color:#606060;font-size:13px;margin-bottom:12px;display:flex;gap:12px;flex-wrap:wrap}
  .channel-row{display:flex;align-items:center;gap:12px;padding:12px 0;border-top:1px solid #eee;border-bottom:1px solid #eee;margin-top:12px}
  .channel-row img{width:48px;height:48px;border-radius:50%;overflow:hidden}
  .channel-row .ch-info{flex:1}
  .btn-sub{background:#cc0000;color:#fff;padding:8px 12px;border-radius:16px;font-weight:700;cursor:pointer}
  .comments{margin-top:12px}
  .comment{display:flex;gap:12px;padding:10px 0;border-bottom:1px solid #f0f0f0}
  .comment img{width:36px;height:36px;border-radius:50%}
  .comment .c-body{flex:1}
  .comment .c-body .name{font-weight:700;font-size:13px}
  .comment .c-body .text{color:#333;margin-top:6px}
  .related-item{display:flex;gap:12px;padding:8px 0;border-bottom:1px solid #f5f5f5;cursor:pointer}
  .related-thumb{width:168px;flex:0 0 168px;overflow:hidden;border-radius:6px}
  .related-info{flex:1}
  .related-info .title{font-size:14px;font-weight:600}
  @media(max-width:900px){
    main{padding:12px}
    .watch-container{flex-direction:column}
    .main-col,.side-col{flex:1 1 100%}
    .related-thumb{width:120px;flex:0 0 120px}
    .search input{max-width:420px}
  }
  .watch-container { display: flex; gap: 20px; height: calc(100vh - 64px - 32px); }
  .main-col { flex: 0 0 60%; display: flex; flex-direction: column; overflow-y: auto; padding-right: 4px; }
  .side-col { flex: 0 0 40%; display: flex; flex-direction: column; overflow-y: auto; padding-left: 4px; }
  .player-box { flex: 0 0 auto; }
  .comments { flex: 1 1 auto; overflow-y: auto; }
</style>
</head>
<body>
    <header>
      <div class="logo" id="homeBtn" title="Home">
        <div class="icon">Y</div>
        <div style="font-weight:700">YouTube</div>
      </div>
      <div class="search">
        <input id="searchInput" placeholder="検索" autocomplete="off" />
      </div>
      <div class="actions">
        <div title="アカウント" style="width:36px;height:36px;border-radius:50%;background:#eee"></div>
      </div>
    </header>
    <main>
      <div class="content" id="app"></div>
    </main>
    <script>
      /* YouTube風シングルファイルデモ（Piped API 版） */

      const PIPED_API_BASE = '/piped';  // ← これに変更！サーバーのプロキシ経由

      const MAX_RESULTS = 12;
      const el = id => document.getElementById(id);
      const app = el('app');
      const searchInput = el('searchInput');
      const homeBtn = el('homeBtn');

      let channelThumbCache = {};
      let homeLoading = false;
      let observerMap = new Map();

      function fmtNum(n){
        if(n==null) return '';
        n = Number(n);
        if(n>=1e9) return (n/1e9).toFixed(1)+'B';
        if(n>=1e6) return (n/1e6).toFixed(1)+'M';
        if(n>=1e3) return (n/1e3).toFixed(1)+'K';
        return String(n);
      }

      function timeAgo(dateStr){
        // PipedのuploadedDateは "X days ago" 形式が多いが、Dateでパース可能なら使う
        const d = new Date(dateStr);
        if (isNaN(d.getTime())) return dateStr; // パース失敗時は生文字列
        const s = Math.floor((Date.now()-d.getTime())/1000);
        if(s<60) return s + '秒前';
        if(s<3600) return Math.floor(s/60)+'分前';
        if(s<86400) return Math.floor(s/3600)+'時間前';
        if(s<2592000) return Math.floor(s/86400)+'日前';
        if(s<31536000) return Math.floor(s/2592000)+'ヶ月前';
        return Math.floor(s/31536000)+'年以上前';
      }

      // Piped 用シンプル fetch ラッパー
// Piped 用シンプル fetch ラッパー（修正版）
async function pipedFetch(endpoint, params = {}) {
  // endpoint が / で始まっている場合もOKにする
  let path = endpoint.startsWith('/') ? endpoint : '/' + endpoint;
  
  // クエリパラメータを安全に構築
  const queryString = new URLSearchParams(params).toString();
  const fullPath = queryString ? `${path}?${queryString}` : path;
  
  // 相対パスで fetch（サーバープロキシ用）
  const response = await fetch(`${PIPED_API_BASE}${fullPath}`, {
    method: 'GET',
    headers: {
      'Accept': 'application/json'
    }
  });

  if (!response.ok) {
    throw new Error(`Piped proxy error: ${response.status} ${response.statusText}`);
  }

  return response.json();
}
      // チャンネルサムネイルキャッシュ（Piped版）
      async function getChannelThumbPiped(channelId) {
        if (channelThumbCache[channelId]) return channelThumbCache[channelId];
        try {
          const data = await pipedFetch(`/channel/${channelId}`);
          const thumb = data.avatarUrl || '';
          channelThumbCache[channelId] = thumb;
          return thumb;
        } catch (e) {
          console.warn('channel thumb failed', e);
          return '';
        }
      }

      // ルーティング（変更なし）
      window.addEventListener('hashchange', renderByHash);
      homeBtn.addEventListener('click', () => { location.hash = ''; });
      searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') performSearch(searchInput.value.trim());
      });
      renderByHash();

      function renderByHash() {
        const h = location.hash.slice(1);
        if (!h) return renderHome();
        const [k, v] = h.split('=');
        if (k === 'watch') return renderWatch(v);
        if (k === 'channel') return renderChannel(v);
        if (k === 'search') {
          searchInput.value = decodeURIComponent(v || '');
          performSearch(decodeURIComponent(v || ''));
          return;
        }
        renderHome();
      }

      // ホーム（trending JP）
      function renderHome() {
        app.innerHTML = `
          <section id="homeSection">
            <div style="margin:12px 0;font-weight:700;font-size:18px">おすすめ</div>
            <div class="video-grid" id="videoGrid"></div>
            <div id="homeSentinel" style="height:32px"></div>
          </section>
        `;
        setupHomeInfinite();
        loadHome();
      }

      async function loadHome() {
        if (homeLoading) return;
        homeLoading = true;
        const grid = el('videoGrid');
        try {
          const data = await pipedFetch('/trending', { region: 'JP' });
          for (const item of data || []) {
            const card = await makeVideoCard(item);  // 名前はそのまま、内部でPiped対応
            grid.appendChild(card);
          }
        } catch (e) {
          console.error(e);
          grid.innerHTML += `<div style="color:#c00">読み込み失敗: ${escapeHtml(e.message)}</div>`;
        } finally {
          homeLoading = false;
        }
      }

      // カード生成（Pipedデータ構造対応）
      async function makeVideoCard(item) {
        const vid = item.url?.split('v=')[1] || item.url?.split('/').pop() || '';
        const title = item.title || '';
        const th = item.thumbnail || '';
        const chId = item.uploaderUrl?.split('/').pop() || '';
        const chTitle = item.uploaderName || '';
        const views = item.views || 0;
        const publishedAt = item.uploadedDate || item.uploaded || '';

        const channelThumb = await getChannelThumbPiped(chId);

        const div = document.createElement('div');
        div.className = 'card';
        div.innerHTML = `
          <div class="thumb" data-vid="${vid}">
            <img src="${th}" alt="">
          </div>
          <div class="meta">
            <div class="channel-thumb"><img src="${channelThumb}" alt=""></div>
            <div class="info">
              <div class="title">${escapeHtml(title)}</div>
              <div class="sub">
                <a href="#channel=${chId}" data-channel="${chId}" class="ch-link">${escapeHtml(chTitle)}</a>
                ・ ${fmtNum(views)} 回視聴 ・ ${timeAgo(publishedAt)}
              </div>
            </div>
          </div>
        `;
        div.querySelector('.thumb').addEventListener('click', () => {
          location.hash = `watch=${vid}`;
        });
        div.querySelector('.ch-link').addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          location.hash = `channel=${chId}`;
        });
        return div;
      }

      function setupHomeInfinite() {
        const sentinel = el('homeSentinel');
        if (!sentinel) return;
        const io = new IntersectionObserver(entries => {
          entries.forEach(ent => { if (ent.isIntersecting) loadHome(); });  // Pipedはページング弱いので再読込
        }, { rootMargin: '400px' });
        io.observe(sentinel);
        observerMap.set('home', io);
      }

      // 検索機能
      async function performSearch(q) {
        if (!q) return renderHome();
        location.hash = `search=${encodeURIComponent(q)}`;
        app.innerHTML = `
          <section>
            <div style="margin:12px 0;font-weight:700;font-size:18px">検索結果: ${escapeHtml(q)}</div>
            <div class="video-grid" id="videoGrid"></div>
            <div id="searchSentinel" style="height:32px"></div>
          </section>
        `;
        const grid = el('videoGrid');
        let loading = false;

        const loadMore = async () => {
  if (loading) return;
  loading = true;
  try {
    const data = await pipedFetch('/search', { q, filter: 'videos' });

    // ここを修正：dataがオブジェクトの場合、配列部分を取り出す
    let items = [];
    if (Array.isArray(data)) {
      items = data;                     // 直接配列の場合
    } else if (data && typeof data === 'object') {
      // よくあるパターン: items, results, または直接配列
      items = data.items || data.results || data.videos || data || [];
    } else {
      items = [];
    }

    for (const item of items) {
      const card = await makeVideoCard(item);
      grid.appendChild(card);
    }

    // 次ページ対応（もしnextpageがあれば）
    if (data.nextpage) {
      // 必要なら次回loadMoreで nextpage を params.nextpage に追加
      // 今回は簡易的に無視（Pipedのsearchはnextpageが不安定）
    }
  } catch (e) {
    console.error(e);
    grid.innerHTML += `<div style="color:#c00">読み込み失敗: ${escapeHtml(e.message)}</div>`;
  } finally {
    loading = false;
  }
};

        const sentinel = el('searchSentinel');
        const io = new IntersectionObserver(entries => {
          entries.forEach(ent => { if (ent.isIntersecting) loadMore(); });
        }, { rootMargin: '400px' });
        io.observe(sentinel);
        observerMap.set('search', io);
        loadMore();
      }

      // 動画再生画面
// 関連動画（Piped依存を避けるため、タイトル検索でフォールバック）
async function loadRelated(videoId, relatedStreams = []) {
  const container = document.getElementById('relatedList');
  container.innerHTML = '<div>読み込み中…</div>';

  if (relatedStreams.length > 0) {
    // すでにデータがあれば使う（ただし今回はスキップ）
  } else {
    try {
      // yt-dlp復活時は /streams を使わないので、代替として動画タイトル検索で関連を取得（簡易）
      // または完全にスキップして「関連動画なし」とする
      // ここは簡易的に「関連動画は現在利用できません」と表示
      container.innerHTML = '<div style="color:#606060">関連動画は現在利用できません（yt-dlpモード）</div>';
      return;
    } catch (e) {
      console.warn('related fetch skipped in yt-dlp mode', e);
      container.innerHTML = '<div style="color:#606060">関連動画は現在利用できません</div>';
    }
  }
}

// コメントはPipedの /comments がまだ動く可能性があるので、そのまま（エラー時は表示）
let commentsPageToken = {};
async function setupComments(videoId) {
  const list = document.getElementById('commentsList');
  list.innerHTML = '';
  commentsPageToken[videoId] = null;
  let loading = false;

  const loadMore = async () => {
    if (loading) return;
    loading = true;
    try {
      const params = { sort_by: 'top' };
      if (commentsPageToken[videoId]) params.nextpage = commentsPageToken[videoId];
      const res = await pipedFetch(`/comments/${videoId}`, params);
      commentsPageToken[videoId] = res.nextpage || null;

      for (const c of res.comments || []) {
        const div = document.createElement('div');
        div.className = 'comment';
        div.innerHTML = `
          <img src="${c.authorThumbnails?.[c.authorThumbnails.length-1]?.url || ''}" alt="">
          <div class="c-body">
            <div class="name">${escapeHtml(c.author || '')} ・ <span style="color:#606060;font-size:12px">${timeAgo(c.published || '')}</span></div>
            <div class="text">${escapeHtml(c.content || '')}</div>
          </div>
        `;
        list.appendChild(div);
      }
      if (!res.comments?.length && !list.innerHTML) {
        list.innerHTML = '<div style="color:#606060">コメントが存在しないか、非表示</div>';
      }
    } catch (e) {
      console.error(e);
      list.innerHTML += `<div style="color:#c00">コメント読み込み失敗（yt-dlpモードでは制限される場合あり）</div>`;
    } finally {
      loading = false;
    }
  };

  const sentinel = el('commentsSentinel');
  const io = new IntersectionObserver(entries => {
    entries.forEach(ent => { if (ent.isIntersecting) loadMore(); });
  }, { rootMargin: '400px' });
  io.observe(sentinel);
  observerMap.set(`comments_${videoId}`, io);
  loadMore();
}

// 再生ページ（メイン変更箇所）
async function renderWatch(videoId) {
  observerMap.forEach(o => o.disconnect());
  observerMap.clear();
  app.innerHTML = `<div>読み込み中...</div>`;

  try {
    // Pipedの /streams は呼ばない（503回避）
    // メタデータは取得せず、公式iframeをデフォルトに
    // タイトルなどは後で /search から取ることも可能だが、今回はシンプルに「読み込み中...」表示
    // 必要に応じて /search?q=動画ID でタイトルだけ取ることもできるが省略

    app.innerHTML = `
      <div class="watch-container">
        <div class="main-col">
          <div class="player-box">
            <iframe id="videoIframe" src="https://www.youtube.com/embed/${videoId}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="width:100%;height:100%;"></iframe>
          </div>
          <div class="player-meta">
            <h1>動画タイトル取得中...（yt-dlpモード）</h1>
            <div class="stats">
              <div>視聴回数 取得中...</div>
              <div>・</div>
              <div>アップロード日 取得中...</div>
              <div style="margin-left:auto;font-weight:700">
                いいね数 取得中...
              </div>
              <select id="playerSelect" style="margin-left:8px">
                <option value="official" selected>公式プレイヤー</option>
                <option value="original">オリジナルプレイヤー (yt-dlp)</option>
              </select>
            </div>
            <div class="channel-row">
              <img src="" alt="チャンネルサムネイル">
              <div class="ch-info">
                <div style="font-weight:700">
                  <a href="#" class="watch-ch-link" style="text-decoration:none;color:inherit">
                    チャンネル名 取得中...
                  </a>
                </div>
                <div style="color:#606060;font-size:13px">登録者数 取得中...</div>
              </div>
              <div class="btn-sub">登録</div>
            </div>
            <div style="margin-top:12px;color:#333">説明文 取得中...</div>
            <div class="comments" id="commentsArea">
              <h3 style="margin-top:12px">コメント</h3>
              <div id="commentsList"></div>
              <div id="commentsSentinel" style="height:32px"></div>
            </div>
          </div>
        </div>
        <aside class="side-col">
          <div style="font-weight:700;margin-bottom:8px">次に再生</div>
          <div id="relatedList"></div>
        </aside>
      </div>
    `;

    // チャンネルリンクイベント（仮）
    const watchChLink = app.querySelector('.watch-ch-link');
    if (watchChLink) {
      watchChLink.addEventListener('click', e => {
        e.preventDefault();
        e.stopPropagation();
        // chIdが取れないので仮にスキップ
        alert('チャンネルページは現在yt-dlpモードで制限されています');
      });
    }

    // コメント読み込み（Piped依存なので動く場合のみ）
    setupComments(videoId);

    // 関連動画（yt-dlpモードではスキップまたは簡易表示）
    loadRelated(videoId, []);

    const playerSelect = document.getElementById('playerSelect');
    const iframe = document.getElementById('videoIframe');

    playerSelect.addEventListener('change', () => {
      if (playerSelect.value === 'official') {
        iframe.src = `https://www.youtube.com/embed/${videoId}`;
      } else {
        // yt-dlp復活: watch.htmlを呼び出して /video エンドポイントでURL取得・再生
        iframe.src = `/watch.html?id=${videoId}`;
      }
    });

  } catch (e) {
    app.innerHTML = `<div style="color:#c00; padding:20px; text-align:center;">
      <h2>再生ページエラー</h2>
      <p>${escapeHtml(e.message)}</p>
      <p>yt-dlpで動画URL取得に失敗しました。cookiesを確認するか、公式プレイヤーをお使いください。</p>
    </div>`;
  }
}

      // チャンネルページ
      async function renderChannel(channelId) {
        app.innerHTML = `<div>チャンネル読み込み中…</div>`;
        try {
          const data = await pipedFetch(`/channel/${channelId}`);
          if (!data || !data.name) throw new Error('チャンネルが見つかりません');

          const title = data.name;
          const desc = data.description || '';
          const thumb = data.avatarUrl || '';
          const subs = data.subscriberCount || 0;

          app.innerHTML = `
            <div style="display:flex;gap:12px;align-items:center;margin-bottom:12px">
              <img src="${thumb}" style="width:88px;height:88px;border-radius:50%">
              <div>
                <div style="font-weight:700;font-size:18px">${escapeHtml(title)}</div>
                <div style="color:#606060">${fmtNum(subs)} 人の登録者</div>
                <div style="margin-top:8px"><button class="btn-sub">登録</button></div>
              </div>
            </div>
            <div style="font-size:13px;color:#333;margin-bottom:12px">${escapeHtml(desc).slice(0,500)}${desc.length>500?'…':''}</div>
            <div style="font-weight:700;margin:12px 0">動画</div>
            <div class="video-grid" id="channelVideos"></div>
            <div id="channelSentinel" style="height:32px"></div>
          `;

          const grid = el('channelVideos');
          let loading = false;

          const loadMore = async () => {
            if (loading) return;
            loading = true;
            try {
              // Pipedのchannelエンドポイントでvideosが返る（一部インスタンスのみnextpage対応）
              const chData = await pipedFetch(`/channel/${channelId}`); // 再取得（簡略化）
              for (const v of chData.relatedStreams || chData.videos || []) {
                const card = await makeVideoCard(v);
                grid.appendChild(card);
              }
            } catch (e) {
              console.error(e);
              grid.innerHTML += `<div style="color:#c00">読み込み失敗</div>`;
            } finally {
              loading = false;
            }
          };

          const sentinel = el('channelSentinel');
          const io = new IntersectionObserver(entries => {
            entries.forEach(ent => { if (ent.isIntersecting) loadMore(); });
          }, { rootMargin: '400px' });
          io.observe(sentinel);
          observerMap.set(`channel_${channelId}`, io);
          loadMore();
        } catch (e) {
          app.innerHTML = `<div style="color:#c00">チャンネル読み込み失敗: ${escapeHtml(e.message)}</div>`;
        }
      }

      function escapeHtml(s = '') {
        return String(s)
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;')
          .replaceAll('"', '&quot;')
          .replaceAll("'", '&#39;');
      }
    </script>

    <!-- パスワード画面部分（変更なし） -->
    <script>
      const correctPassword = "manabinotobira";
      const input = document.getElementById('passwordInput');
      const btn = document.getElementById('passwordBtn');
      const msg = document.getElementById('passwordMsg');
      const screen = document.getElementById('passwordScreen');
      const content = document.getElementById('mainContent');
      btn.addEventListener('click', () => {
        if(input.value === correctPassword){
          screen.style.display = 'none';
          content.style.display = 'block';
        } else {
          msg.textContent = '利用コードが違います';
          input.value = '';
          input.focus();
        }
      });
      input.addEventListener('keydown', e => {
        if(e.key === 'Enter') btn.click();
      });

      window.addEventListener('load', () => {
        fetch('https://teaching-materials-r4zf.onrender.com/', { mode: 'no-cors' }).catch(()=>{});
        fetch('https://teaching-materials-r4zf.onrender.com/watch.html?id=dummy', { mode: 'no-cors' }).catch(()=>{});
      });
    </script>
</body>
</html>
