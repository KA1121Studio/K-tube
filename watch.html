<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Video Player (MSE)</title>
  <style>
    body { margin:0; background:#000; color:#fff; font-family:sans-serif; }
    #container { position:relative; width:100%; height:100vh; }
    video { width:100%; height:100%; }
    #error { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:#f33; background:rgba(0,0,0,0.7); padding:20px; border-radius:8px; max-width:80%; text-align:center; display:none; }
  </style>
</head>
<body>
<div id="container">
  <video id="video" controls autoplay playsinline></video>
  <div id="error"></div>
</div>

<script>
// エラーメッセージ表示ヘルパー
function showError(msg) {
  const errDiv = document.getElementById('error');
  errDiv.textContent = msg;
  errDiv.style.display = 'block';
}

const params = new URLSearchParams(window.location.search);
const videoId = params.get("id");
if (!videoId) {
  showError("動画IDが指定されていません");
  throw new Error("No video ID");
}

// MSE対応チェック
if (!('MediaSource' in window) || !MediaSource.isTypeSupported) {
  showError("お使いのブラウザはMedia Source Extensionsをサポートしていません");
  throw new Error("MSE not supported");
}

const video = document.getElementById('video');
const mediaSource = new MediaSource();
video.src = URL.createObjectURL(mediaSource);

// 再生準備完了時に自動再生（mutedで開始推奨）
video.muted = true; // 初回自動再生のため
video.playsInline = true;

let videoSourceBuffer = null;
let audioSourceBuffer = null;
let videoMime = 'video/mp4; codecs="avc1.64001F"'; // H.264 高プロファイル例（yt-dlpのmp4はだいたいこれ）
let audioMime = 'audio/mp4; codecs="mp4a.40.2"';   // AAC

// MIMEタイプをyt-dlpのレスポンスから動的に取得したい場合は後述

mediaSource.addEventListener('sourceopen', async () => {
  try {
    // yt-dlpからストリームURLを取得
    const res = await fetch(`/video?id=${videoId}`);
    if (!res.ok) throw new Error(`サーバーエラー: ${res.status}`);
    
    const data = await res.json();
    if (!data.video || !data.audio) {
      throw new Error("動画または音声URLが取得できません");
    }

    const videoUrl = `/proxy?url=${encodeURIComponent(data.video)}`;
    const audioUrl = `/proxy?url=${encodeURIComponent(data.audio)}`;

    // SourceBuffer追加（追加前にisTypeSupportedでチェック推奨）
    if (!MediaSource.isTypeSupported(videoMime)) {
      throw new Error("この動画コーデックはサポートされていません: " + videoMime);
    }
    if (!MediaSource.isTypeSupported(audioMime)) {
      throw new Error("この音声コーデックはサポートされていません: " + audioMime);
    }

    videoSourceBuffer = mediaSource.addSourceBuffer(videoMime);
    audioSourceBuffer = mediaSource.addSourceBuffer(audioMime);

    // 更新中はappend禁止にするためのフラグ管理（簡易版）
    const appendToBuffer = (buffer, url) => {
      return new Promise((resolve, reject) => {
        if (buffer.updating) {
          buffer.addEventListener('updateend', () => {
            fetchAndAppend(buffer, url).then(resolve).catch(reject);
          }, { once: true });
          return;
        }
        fetchAndAppend(buffer, url).then(resolve).catch(reject);
      });
    };

const fetchAndAppend = async (buffer, url) => {
  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`フェッチ失敗: ${response.status}`);
    
    const arrayBuffer = await response.arrayBuffer();
    buffer.appendBuffer(arrayBuffer);

    // 更新終了時にチェック
    buffer.addEventListener('updateend', () => {
      if (!buffer.updating && mediaSource.readyState === 'open') {
        // 両方のSourceBufferが更新中でない → 終了
        if (!videoSourceBuffer.updating && !audioSourceBuffer.updating) {
          mediaSource.endOfStream();  // ← ここを無引数に！
        }
      }
    }, { once: true });

  } catch (err) {
    console.error(err);
    showError("ストリーム読み込みエラー: " + err.message);
    
    if (mediaSource.readyState === 'open') {
      mediaSource.endOfStream('network');  // ← ここは 'network' に変更（または無引数）
    }
  }
};

    // 並列でフェッチ＆アペンド（順不同でOK、MSEが内部で同期）
    await Promise.all([
      appendToBuffer(videoSourceBuffer, videoUrl),
      appendToBuffer(audioSourceBuffer, audioUrl)
    ]);

    // ミュート解除（ユーザーインタラクション後なら自動再生OK）
    video.muted = false;

  } catch (err) {
    console.error(err);
    showError("再生準備エラー: " + err.message);
    if (mediaSource.readyState === 'open') {
      mediaSource.endOfStream('error');
    }
  }
});

// エラー監視
video.addEventListener('error', (e) => {
  showError("動画再生エラー: " + (video.error?.message || "不明"));
});
</script>
</body>
</html>
